<%- include('include/_header') -%>

<main class="home-main">
  <section class="hero">
    <div class="hero-content">
      <img src="/img/logo-horizontal-transp-white.png" alt="Power Up Project" class="hero-logo"/>
      <p class="tagline">Changing the world, one computer at a time.</p>
    </div>
  </section>

  <section class="home-section">
    <% if (galleryImages && galleryImages.length > 0) { %>
      <div class="bulletin-board">
        <div id="galleryScatter" class="gallery-scatter">
        <% galleryImages.forEach((image, idx) => { %>
          <div class="gallery-item" data-idx="<%= idx %>">
            <span class="pin pin-photo" aria-hidden="true"></span>
            <div class="inner">
              <img src="data:image/jpeg;base64,<%= image.imageData.toString('base64') %>" alt="<%= image.name %>">
            </div>
          </div>
        <% }) %>
        </div>
        <% if (recentBlogs && recentBlogs.length > 0) { %>
          <div class="recent-news-wrapper">
            <h2>Recent News</h2>
            <div id="recentBlogs" class="blog-container bulletin-recent">
            <% recentBlogs.forEach(blog => { %>
              <a href="/blog/<%= blog._id %>" class="blog-card">
                <span class="pin pin-note" aria-hidden="true"></span>
                <div class="blog-card-content">
                  <h3><%= blog.title %></h3>
                  <p><%= blog.content.substring(0, 100) %>...</p>
                  <span class="blog-card-date"><%= new Date(blog.date).toLocaleDateString() %></span>
                </div>
              </a>
            <% }) %>
            </div>
          </div>
        <% } %>
      </div>
    <% } %>

    <% if (testimonials && testimonials.length > 0) { %>
      <div id="testimonialCards" class="testimonial-container" aria-label="Testimonials">
        <div class="testimonial-ticker" aria-hidden="true">
          <div class="testimonial-track" role="list">
        <% testimonials.forEach(testimonial => { %>
          <div class="testimonial-card" role="listitem">
            <p class="testimonial-content">"<%= testimonial.content %>"</p>
            <p class="testimonial-author">- <%= testimonial.partnerName %></p>
          </div>
        <% }) %>
          </div>
        </div>
          </div>
        </div>
        <!-- screen-reader friendly static list -->
        <div class="sr-only" aria-hidden="false">
          <div role="list">
            <% testimonials.forEach(testimonial => { %>
              <div role="listitem">"<%= testimonial.content %>" â€” <%= testimonial.partnerName %></div>
            <% }) %>
          </div>
        </div>
      </div>
    <% } %>

  </section>
  <section class="home-section alt-bg">
    <h2>Who Are We?</h2>
    <p>The Power Up Project is a charitable organization founded by high school students in 2018. Our mission is to increase computer accessibility and decrease electronic waste.<br>With the generous contributions of our donors, members, and sponsors, we strive to improve the lives of those in need and better our community.</p>
    <h2>What Do We Do?</h2>
    <p>We refurbish donated computers and distribute them to organizations and individuals in need across Chicagoland. Our process is simple:</p>
    <ul class="process-list">
      <li>We accept computer donations from individuals and businesses.</li>
      <li>Our team of volunteers refurbishes the computers, ensuring they are in good working condition.</li>
      <li>We distribute the refurbished computers to local organizations and individuals who lack access to technology.</li>
    </ul>
  </section>
  

<section class="home-section alt-bg">
  <h2>Get Involved</h2>
  <p>There are many ways to support The Power Up Project:</p>
  <ul class="involvement-list">
    <li>
      <div>
        <strong>Donate:</strong> We accept donations of used computers, laptops, and tablets. Your old devices can make a big difference in someone's life.
      </div>
      <a href="/donate" class="btn">Donate Now</a>
    </li>
    <li>
      <div>
        <strong>Volunteer:</strong> Join our team of dedicated volunteers who help with computer refurbishment, distribution, and community outreach.
      </div>
      <a href="/join" class="btn">Join Our Team</a>
    </li>
    <li><strong>Spread the Word:</strong> Follow us on social media and share our mission with your network to help us reach more people in need.</li>
  </ul>
</section>

  
</main>

<script>
  (function () {
    const container = document.getElementById('galleryScatter');
    const recentEl = document.getElementById('recentBlogs');
    if (!container) return;

    const items = Array.from(container.querySelectorAll('.gallery-item'));

    // wait for all images to load
    const imgs = items.map(it => it.querySelector('img'));
    Promise.all(imgs.map(img => new Promise(res => {
      if (img.complete) return res();
      img.addEventListener('load', res);
      img.addEventListener('error', res);
    }))).then(positionItems);

    // simple rectangle overlap checker
    function overlaps(a, b) {
      return !(a.left + a.w < b.left || b.left + b.w < a.left || a.top + a.h < b.top || b.top + b.h < a.top);
    }
    
      // style the recent news notes: random rotate and slight background offsets for variety
      function styleNewsNotes() {
        const news = document.getElementById('recentBlogs');
        if (!news) return;
        const notes = Array.from(news.querySelectorAll('.blog-card'));
        notes.forEach((note, idx) => {
          // apply small random rotation between -6 and 6 degrees
          const rot = (Math.random() * 12) - 6;
          note.style.transform = `rotate(${rot}deg)`;
          note.style.zIndex = 300 + idx;
        });
      }
      // initial style
      styleNewsNotes();
      window.addEventListener('resize', () => {
        // keep news notes fairly upright on very small screens
        setTimeout(styleNewsNotes, 120);
      });

    function positionItems() {
      const cw = container.clientWidth;
      // choose a container height relative to viewport for more scatter room,
      // leaving room for the recent news section at the bottom of the bulletin board
      const rawCh = Math.max(window.innerHeight * 0.75, 520);
      const reserved = (recentEl && recentEl.offsetHeight) ? recentEl.offsetHeight + 18 : 140;
      const ch = Math.max(260, rawCh - reserved);
      container.style.height = ch + 'px';

      const placed = [];

      // Mobile: if small screen, stop the scatter logic and show only 2 images stacked vertically.
      if (window.matchMedia && window.matchMedia('(max-width: 768px)').matches) {
        // allow css to render items in normal flow; clear inline positioning styles
        container.style.height = 'auto';
        items.forEach((item, idx) => {
          // show only first two items
          if (idx >= 2) {
            item.style.display = 'none';
          } else {
            item.style.display = '';
            // clear scatter positioning and sizing applied by JS
            item.style.left = '';
            item.style.top = '';
            item.style.width = '';
            item.style.height = '';
            item.style.transform = '';
            item.style.zIndex = '';
            const inner = item.querySelector('.inner');
            if (inner) {
              // Re-enable float for mobile so the visible items have subtle motion
              if (Math.random() > 0.4) {
                inner.classList.add('float');
                inner.style.animationDelay = (Math.random() * 1.5) + 's';
              }
            }
          }
        });
        return;
      }
      // ensure items are visible on desktop (clears any display:none we set for mobile)
      items.forEach(item => { item.style.display = ''; });
      // padding around elements (in px) to avoid two items visually touching
      const paddingMargin = 12;

      items.forEach(item => {
        const img = item.querySelector('img');
        const naturalW = img.naturalWidth || img.width;
        const naturalH = img.naturalHeight || img.height;
        const cssMaxW = parseInt(getComputedStyle(img).maxWidth) || Math.min(320, cw * 0.35);
        const cssMaxH = parseInt(getComputedStyle(img).maxHeight) || 260;

        let iw = naturalW;
        let ih = naturalH;
        const scale = Math.min(1, cssMaxW / iw, cssMaxH / ih);
        iw = Math.round(iw * scale);
        ih = Math.round(ih * scale);

        // account for gallery-item padding (box-sizing: border-box) and inner frame padding
        const itemStyles = getComputedStyle(item);
        const padX = parseInt(itemStyles.paddingLeft || 0) + parseInt(itemStyles.paddingRight || 0);
        const padY = parseInt(itemStyles.paddingTop || 0) + parseInt(itemStyles.paddingBottom || 0);
        const innerEl = item.querySelector('.inner');
        const innerStyles = innerEl ? getComputedStyle(innerEl) : null;
        const innerPadX = innerStyles ? (parseInt(innerStyles.paddingLeft || 0) + parseInt(innerStyles.paddingRight || 0)) : 0;
        const innerPadY = innerStyles ? (parseInt(innerStyles.paddingTop || 0) + parseInt(innerStyles.paddingBottom || 0)) : 0;
        const cardScale = 1.5;
        const cardW = Math.round((iw + padX + innerPadX) * cardScale);
        const cardH = Math.round((ih + padY + innerPadY) * cardScale);
        item.style.width = cardW + 'px';
        item.style.height = cardH + 'px';

        // Try to place items with minimal overlap. We progressively allow small
        // overlaps if we can't find a no-overlap spot after many tries.
        let attempts = 0;
        let left = 0, top = 0;
        const maxAttempts = 360; // allow more tries to find a non-overlapping spot
        const attemptStep = 30; // attempts before allowing more overlap
        const allowedThresholds = [0, 0.005, 0.015, 0.03]; // stricter overlap thresholds (up to 3%)
        let thresholdIndex = 0;
        let allowed = allowedThresholds[thresholdIndex];
        // Keep track of the best spot found (least overlap) as fallback if no spot meets the allowed threshold
        let bestSpot = { left: 0, top: 0, worst: Infinity };

        function overlapArea(a, b) {
          // pad rects by paddingMargin to create a visual buffer space
          const ax1 = a.left - paddingMargin;
          const ay1 = a.top - paddingMargin;
          const ax2 = a.left + a.w + paddingMargin;
          const ay2 = a.top + a.h + paddingMargin;
          const bx1 = b.left - paddingMargin;
          const by1 = b.top - paddingMargin;
          const bx2 = b.left + b.w + paddingMargin;
          const by2 = b.top + b.h + paddingMargin;
          const xOverlap = Math.max(0, Math.min(ax2, bx2) - Math.max(ax1, bx1));
          const yOverlap = Math.max(0, Math.min(ay2, by2) - Math.max(ay1, by1));
          return xOverlap * yOverlap;
        }

        function overlapRatio(a, b) {
          const area = a.w * a.h;
          const barea = b.w * b.h;
          const overlap = overlapArea(a, b);
          if (overlap === 0) return 0;
          // Use smaller area to be conservative (overlap / smaller piece)
          return overlap / Math.min(area, barea);
        }

        do {
          left = Math.round(Math.random() * Math.max(0, cw - cardW));
          top  = Math.round(Math.random() * Math.max(0, ch - cardH));
          attempts++;
          const rect = { left, top, w: cardW, h: cardH };
          // find the worst overlap (relative to the smaller element) across all placed items
          const worstOverlap = placed.reduce((max, p) => Math.max(max, overlapRatio(rect, p)), 0);
          // remember the best (least-overlap) spot
          if (worstOverlap < bestSpot.worst) {
            bestSpot.left = left;
            bestSpot.top = top;
            bestSpot.worst = worstOverlap;
          }
          if (worstOverlap <= allowed) break;
          if (attempts % attemptStep === 0 && thresholdIndex < allowedThresholds.length - 1) {
            thresholdIndex++;
            allowed = allowedThresholds[thresholdIndex];
          }
        } while (attempts < maxAttempts);

        // if we exhausted attempts, use the best spot found (least overlap) as a fallback
        const finalRect = { left, top, w: iw, h: ih };
        if (attempts >= maxAttempts) {
          left = bestSpot.left;
          top = bestSpot.top;
        }

        placed.push({ left, top, w: cardW, h: cardH });

        const rotate = (Math.random() * 20) - 10; 
        // Position the element absolute using left/top and set rotation separately.
        item.style.left = left + 'px';
        item.style.top = top + 'px';
        item.style.transform = `rotate(${rotate}deg)`;
        item.style.zIndex = 10 + Math.floor(Math.random() * 50);
        item.style.zIndex = 10 + Math.floor(Math.random() * 50);

        const inner = item.querySelector('.inner');
        if (inner && Math.random() > 0.2) {
          inner.classList.add('float');
          inner.style.animationDelay = (Math.random() * 2) + 's';
        }
      });
    }

    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(positionItems, 220);
    });
    window.addEventListener('orientationchange', () => setTimeout(positionItems, 300));
  })();

  // Testimonial ticker (home page only)
  (function setupHomeTestimonialTicker() {
    const ticker = document.querySelector('.testimonial-ticker');
    if (!ticker) return;
    const track = ticker.querySelector('.testimonial-track');
    if (!track) return;

    // Respect reduced-motion preference
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    if (mediaQuery.matches) return;

    if (!track.dataset.baseHtml) track.dataset.baseHtml = track.innerHTML;
    const baseHTML = track.dataset.baseHtml || '';
    if (!baseHTML.trim()) return;
    // start with single copy so we can measure properly
    track.innerHTML = baseHTML;

    function update() {
      track.classList.remove('ticker-animate');
      track.style.animationDuration = '';
      const tickerHeight = ticker.clientHeight;
      const baseHeight = track.scrollHeight; // height of a single set
      if (baseHeight <= tickerHeight) {
        // no need to animate
        track.innerHTML = baseHTML;
        track.classList.remove('ticker-animate');
        track.style.animationDuration = '';
        track.style.transform = '';
        return;
      }
      // duplicate if not already duplicated
      if (!track.dataset.duplicated || track.dataset.duplicated !== 'true') {
        track.innerHTML = baseHTML + baseHTML;
        track.dataset.duplicated = 'true';
        track.style.transform = 'translateY(0)';
      }
      const originalHeight = track.scrollHeight / 2;
      const pxPerSec = 35;
      const duration = Math.max(6, Math.round(originalHeight / pxPerSec));
      track.style.animationDuration = duration + 's';
      // trigger animation
      track.classList.add('ticker-animate');
    }

    // Pause on hover
    ticker.addEventListener('mouseenter', () => { track.style.animationPlayState = 'paused'; });
    ticker.addEventListener('mouseleave', () => { track.style.animationPlayState = 'running'; });

    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(update, 150);
    });
    update();
  })();
</script>
<%- include('include/_footer') -%>