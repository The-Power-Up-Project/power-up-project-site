<%- include('include/_header') -%>

<main class="home-main">
  <section class="hero">
    <div class="hero-content">
      <img src="/img/logo-horizontal-transp-white.png" alt="Power Up Project" class="hero-logo"/>
      <p class="tagline">Changing the world, one computer at a time.</p>
    </div>
  </section>

  <section class="home-section">
    <% if (galleryImages && galleryImages.length > 0) { %>
      <div class="bulletin-board">
        <div id="galleryScatter" class="gallery-scatter">
        <% galleryImages.forEach((image, idx) => { %>
          <div class="gallery-item" data-idx="<%= idx %>">
            <span class="pin pin-photo" aria-hidden="true"></span>
            <div class="inner">
              <img src="data:image/jpeg;base64,<%= image.imageData.toString('base64') %>" alt="<%= image.name %>">
            </div>
          </div>
        <% }) %>
        </div>
        <% if (recentBlogs && recentBlogs.length > 0) { %>
          <div class="recent-news-wrapper">
            <h2>Recent News</h2>
            <div id="recentBlogs" class="blog-container bulletin-recent">
            <% recentBlogs.forEach(blog => { %>
              <a href="/blog/<%= blog._id %>" class="blog-card">
                <div class="blog-card-content">
                  <h3><%= blog.title %></h3>
                  <p><%= blog.content.substring(0, 100) %>...</p>
                  <span class="blog-card-date"><%= new Date(blog.date).toLocaleDateString() %></span>
                </div>
              </a>
            <% }) %>
            </div>
          </div>
        <% } %>
      </div>
    <% } %>

  </section>

  <section class="home-section alt-bg">
    <div class="recent-testimonials">
      <h2>Recent Testimonials</h2>
      <div class="testimonials-grid">
        <% for (const testimonial of testimonials) { %>
          <div class="testimonial-card">
            <p><%= testimonial.content %></p>
            <h3>
              <strong><%= testimonial.partnerName %></strong>
            </h3>
          </div>
        <% }%>
      </div>
    </div>
  </section>
  <section class="home-section alt-bg">
    <div class="about">
      <h2>Who Are We?</h2>
      <ul class="process-list">
      <li>We are a non-profit organization based in Naperville, IL founded by high school students in 2018</li>
      <li>Our mission is to increase computer accessibility and decrease electronic waste.</li>
      <li>We strive to improve the lives of those in need and better our community.</li>
      <li>We are a member of the state-sponsored Illinois Computer Equity Network</li>
    </ul>
      <h2>What Do We Do?</h2>
      <ul class="process-list">
      <li>We accept computer donations from individuals and businesses.</li>
      <li>Our team of volunteers refurbishes the computers, ensuring they are in good working condition.</li>
      <li>We distribute the refurbished computers to local organizations and individuals who lack access to technology.</li>
    </ul>
    </div>
  </section>
  

<section class="home-section alt-bg">
  <div class="get-involved">
    <h2>Get Involved</h2>
    <div class="get-involved-cta">
    <a href="/donate" class="btn btn-lg">Donate Now</a>
    <a href="/join" class="btn btn-lg">Join Our Team</a>
    </div>
  </div>
</section>

  
</main>

<script>
  (function () {
    const container = document.getElementById('galleryScatter');
    const recentEl = document.getElementById('recentBlogs');
    if (!container) return;

    const items = Array.from(container.querySelectorAll('.gallery-item'));

    // wait for all images to load
    const imgs = items.map(it => it.querySelector('img'));
    Promise.all(imgs.map(img => new Promise(res => {
      if (img.complete) return res();
      img.addEventListener('load', res);
      img.addEventListener('error', res);
    }))).then(positionItems);

    // simple rectangle overlap checker
    function overlaps(a, b) {
      return !(a.left + a.w < b.left || b.left + b.w < a.left || a.top + a.h < b.top || b.top + b.h < a.top);
    }
    
      // style the recent news notes: random rotate and slight background offsets for variety
      function styleNewsNotes() {
        const news = document.getElementById('recentBlogs');
        if (!news) return;
        const notes = Array.from(news.querySelectorAll('.blog-card'));
        notes.forEach((note, idx) => {
          // apply small random rotation between -6 and 6 degrees
          const rot = (Math.random() * 12) - 6;
          note.style.transform = `rotate(${rot}deg)`;
          note.style.zIndex = 300 + idx;
        });
      }
      // initial style
      styleNewsNotes();
      window.addEventListener('resize', () => {
        // keep news notes fairly upright on very small screens
        setTimeout(styleNewsNotes, 120);
      });

    function positionItems() {
      const cw = container.clientWidth;
      // choose a container height relative to viewport for more scatter room,
      // leaving room for the recent news section at the bottom of the bulletin board
      const rawCh = Math.max(window.innerHeight * 0.75, 520);
      const reserved = (recentEl && recentEl.offsetHeight) ? recentEl.offsetHeight + 18 : 140;
      const ch = Math.max(260, rawCh - reserved) + 80;
      container.style.height = ch + 'px';

      // Mobile: if small screen, stop the scatter logic and show only 2 images stacked vertically.
      if (window.matchMedia && window.matchMedia('(max-width: 768px)').matches) {
        // allow css to render items in normal flow; clear inline positioning styles
        container.style.height = 'auto';
        items.forEach((item, idx) => {
          // show only first two items
          if (idx >= 2) {
            item.style.display = 'none';
          } else {
            item.style.display = '';
            // clear scatter positioning and sizing applied by JS
            item.style.left = '';
            item.style.top = '';
            item.style.width = '';
            item.style.height = '';
            item.style.transform = '';
            item.style.zIndex = '';
            const inner = item.querySelector('.inner');
            if (inner) {
              // Re-enable float for mobile so the visible items have subtle motion
              if (Math.random() > 0.4) {
                inner.classList.add('float');
                inner.style.animationDelay = (Math.random() * 1.5) + 's';
              }
            }
          }
        });
        return;
      }
      // ensure items are visible on desktop (clears any display:none we set for mobile)
      items.forEach(item => { item.style.display = ''; });

      const cols = 4;
      const rows = Math.ceil(items.length / cols);
      const colWidth = cw / cols;
      const rowHeight = ch / Math.max(2, rows); 

      const itemData = items.map((item, i) => {
        const img = item.querySelector('img');
        const naturalW = img.naturalWidth || img.width;
        const naturalH = img.naturalHeight || img.height;
        
        const cssMaxW = Math.min(250, colWidth * 0.85);
        const cssMaxH = parseInt(getComputedStyle(img).maxHeight) || 220;

        let iw = naturalW;
        let ih = naturalH;
        const scale = Math.min(1, cssMaxW / iw, cssMaxH / ih);
        iw = Math.round(iw * scale);
        ih = Math.round(ih * scale);

        const itemStyles = getComputedStyle(item);
        const padX = parseInt(itemStyles.paddingLeft || 0) + parseInt(itemStyles.paddingRight || 0);
        const padY = parseInt(itemStyles.paddingTop || 0) + parseInt(itemStyles.paddingBottom || 0);
        const innerEl = item.querySelector('.inner');
        const innerStyles = innerEl ? getComputedStyle(innerEl) : null;
        const innerPadX = innerStyles ? (parseInt(innerStyles.paddingLeft || 0) + parseInt(innerStyles.paddingRight || 0)) : 0;
        const innerPadY = innerStyles ? (parseInt(innerStyles.paddingTop || 0) + parseInt(innerStyles.paddingBottom || 0)) : 0;
        
        const baseW = iw + padX + innerPadX;
        const baseH = ih + padY + innerPadY;
        
        const col = i % cols;
        const row = Math.floor(i / cols);
        const centerX = (col * colWidth) + (colWidth / 2);
        let centerY = (row * rowHeight) + (rowHeight / 2);

        if (rows > 1) {
            const separation = 40;
            centerY += (row < rows / 2) ? -separation : separation;
        }
        
        const rotate = (Math.random() * 16) - 8; 

        return {
            item,
            baseW,
            baseH,
            centerX,
            centerY,
            rotate
        };
      });

      let globalScale = 1.0;
      let iterations = 0;
      const maxIterations = 10;

      while (iterations < maxIterations) {
          const rects = itemData.map(d => {
              const w = d.baseW * globalScale;
              const h = d.baseH * globalScale;
              const rad = d.rotate * (Math.PI / 180);
              const sin = Math.abs(Math.sin(rad));
              const cos = Math.abs(Math.cos(rad));
              const bboxW = w * cos + h * sin;
              const bboxH = w * sin + h * cos;
              const bboxLeft = d.centerX - (bboxW / 2);
              const bboxTop = d.centerY - (bboxH / 2);
              return { left: bboxLeft, top: bboxTop, w: bboxW, h: bboxH, area: w * h };
          });

          let maxOverlapPct = 0;
          for (let i = 0; i < rects.length; i++) {
              for (let j = i + 1; j < rects.length; j++) {
                  const r1 = rects[i];
                  const r2 = rects[j];
                  const x_overlap = Math.max(0, Math.min(r1.left + r1.w, r2.left + r2.w) - Math.max(r1.left, r2.left));
                  const y_overlap = Math.max(0, Math.min(r1.top + r1.h, r2.top + r2.h) - Math.max(r1.top, r2.top));
                  const overlapArea = x_overlap * y_overlap;
                  if (overlapArea > 0) {
                      const pct1 = overlapArea / r1.area;
                      const pct2 = overlapArea / r2.area;
                      maxOverlapPct = Math.max(maxOverlapPct, pct1, pct2);
                  }
              }
          }
          if (maxOverlapPct < 0.10) break;
          globalScale *= 0.9;
          iterations++;
      }

      itemData.forEach((d, i) => {
          const w = Math.round(d.baseW * globalScale);
          const h = Math.round(d.baseH * globalScale);
          const left = d.centerX - (w / 2);
          const top = d.centerY - (h / 2);

          d.item.style.width = w + 'px';
          d.item.style.height = h + 'px';
          d.item.style.left = left + 'px';
          d.item.style.top = top + 'px';
          d.item.style.transform = `rotate(${d.rotate}deg)`;
          d.item.style.zIndex = 10 + i;

          const inner = d.item.querySelector('.inner');
          if (inner && Math.random() > 0.2) {
            inner.classList.add('float');
            inner.style.animationDelay = (Math.random() * 2) + 's';
          }
      });
    }

    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(positionItems, 220);
    });
    window.addEventListener('orientationchange', () => setTimeout(positionItems, 300));
  })();

  // Testimonial ticker (home page only)
  (function setupHomeTestimonialTicker() {
    const ticker = document.querySelector('.testimonial-ticker');
    if (!ticker) return;
    const track = ticker.querySelector('.testimonial-track');
    if (!track) return;

    // Respect reduced-motion preference
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    if (mediaQuery.matches) return;

    if (!track.dataset.baseHtml) track.dataset.baseHtml = track.innerHTML;
    const baseHTML = track.dataset.baseHtml || '';
    if (!baseHTML.trim()) return;
    // start with single copy so we can measure properly
    track.innerHTML = baseHTML;

    function update() {
      track.classList.remove('ticker-animate');
      track.style.animationDuration = '';
      const tickerHeight = ticker.clientHeight;
      const baseHeight = track.scrollHeight; // height of a single set
      if (baseHeight <= tickerHeight) {
        // no need to animate
        track.innerHTML = baseHTML;
        track.classList.remove('ticker-animate');
        track.style.animationDuration = '';
        track.style.transform = '';
        return;
      }
      // duplicate if not already duplicated
      if (!track.dataset.duplicated || track.dataset.duplicated !== 'true') {
        track.innerHTML = baseHTML + baseHTML;
        track.dataset.duplicated = 'true';
        track.style.transform = 'translateY(0)';
      }
      const originalHeight = track.scrollHeight / 2;
      const pxPerSec = 35;
      const duration = Math.max(6, Math.round(originalHeight / pxPerSec));
      track.style.animationDuration = duration + 's';
      // trigger animation
      track.classList.add('ticker-animate');
    }

    // Pause on hover
    ticker.addEventListener('mouseenter', () => { track.style.animationPlayState = 'paused'; });
    ticker.addEventListener('mouseleave', () => { track.style.animationPlayState = 'running'; });

    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(update, 150);
    });
    update();
  })();
</script>
<%- include('include/_footer') -%>